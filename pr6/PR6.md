# Практическая работа №6
## 1 Введение 
Цель работы : Получение навыков реализации обхода бинарного дерева поиска на языке С, выработка практических умений написания программ на языке С. 

Задание на практическую работу:
1) Прочитать про бинарные дервья на СИ
2) Написать три программы обхода дерева
3) Настроить pipeline
4) Написать отчет по работе в разметке Markdown 
5) Залить на gitlab и убедиться, что pipeline проходит успешно
6) Защитить работу у преподавателя
## 2 Ход работы
### 2.1 Настойка pipeline
Настройка pipeline проходит в файле .gitlab_ci.yml. Было добавлено в пункт stages: pr6.
```sh
stages:
  - pr1
  - pr2
  - pr3
  - pr4
  - pr5
  - pr6
```
Раскомментированы настройки для четвертой практической работы.
```sh
pr6_01_test:
  stage: pr6
  only:
    changes:
      - pr6/*.c
  script:
  - gcc pr6/01_*.c
  - python3 pr6/tests/checker.py 0
pr6_02_test:
  stage: pr6
  only:
    changes:
      - pr6/*.c
  script:
  - gcc pr6/02_*.c
  - python3 pr6/tests/checker.py 1
pr6_03_test:
  stage: pr6
  only:
    changes:
      - pr6/*.c
  script:
  - gcc pr6/03_*.c
  - python3 pr6/tests/checker.py 2
  ```
  
### 2.2 Программа №1
Основные функциии реализующие бинарное дерево были взяты из предыдущей работы. В первой программе был реализован обход дерева в ширину. Для наглядноссти обхода возьмем следующие узлы дерева: 5 3 7 2 4 6 8. На рисунке 2.2.1 показан обход дерева в ширину.

  ![Screenshot_44.png](https://www.dropbox.com/s/l6p96q197k97bn3/Screenshot_44.png?dl=0&raw=1)
  
  *Рисунок 2.2.1 - Обход в ширину*
  
То есть, беруться узлы по уровням: сначала корневой, затем узлы следующего уровня, начиная с самого левого, затем переходит на следующий уровень и считывает аналогично все узлы и так далее. В данном случае результат обхода, считывания будет следующим: 5 3 7 2 4 6 8. Ниже представлен код функции обхода в ширину.
```sh
int printWidth(struct node* t)
{
	struct node *Temp = t;
    int Rang = 0, i, j, k, sk, Spaces = 0; 
    int *comb;
    Rang = deepness(t);
    comb = (int*)malloc(sizeof(int));
    for (i = 0; i < Rang; i++)//обработка рангов
    {
        if (i != 0)//объявление-зануление
        {
            comb = (int*)realloc(comb, i * sizeof(int)); 
            for (j = 0; j < i; j++)
                comb[j] = 0;
        }
        j = 1; 
        sk = i;
        while (sk != 0)//получение кол-ва элементов на уровне
        {
            j = j * 2; 
            sk--;
        }
        while (j != 0)//проход для каждого элемент
        {
            k = 0; 
            Temp = t;
            for (k = 0; k < i; k++)//проход до определённого узла
            {
                if (comb[k] == 0)
                {
                    if ((Temp->left) != NULL) 
                        Temp = Temp->left;
                    else
                    {
                        k = -1; 
                        break;
                    }
                }
                else
                {
                    if ((Temp->right) != NULL) 
                        Temp = Temp->right;
                    else
                    {
                        k = -1; 
                        break;
                    }
                }
            }
            if (i != 0)//изменяем массив, если он вообще существует
            {
                sk = i - 1; 
                comb[sk]++; 
                while (1)
                {
                    if (comb[sk] == 2)
                    {
                        comb[sk] = 0; 
                        sk--;
                        if (sk < 0) 
                            break;
                        else
                        comb[sk]++;
                    }
                    else
                        break;
                }
            }
            if (k != -1)//если элемент есть вообще
            {
                if (Spaces == 1)
                {
                    printf(" "); 
                    Spaces = 1;
                }
                printf("%d", (int)Temp->data); 
                Spaces = 1;
            }
        j--;
        }//конец ряда
    }
    return 0;
}
 ```
 И функция Main, в которой описаны основные действия программы.
 ```sh
 int main(){
    int x, i;
    struct tree tr;
    init(&tr);
    for (i = 0; i < 7; i++){
		scanf("%d", &x);
		insert(&tr, x);
	}
	printWidth(get_root(&tr));
	printf("\n");
    return 0;
}
  ```
 Проверим работу написанной программы. Компиляция, работа программы представлена на рисунке 2.2.2.
 
 ![Screenshot from 2021-05-31 21-19-44.png](https://www.dropbox.com/s/t7gqn4r5mia0fox/Screenshot%20from%202021-05-31%2021-19-44.png?dl=0&raw=1)
 
   *Рисунок 2.2.2 - Работа программы*

Сравнивая работу программы на рисунке 2.2.2 с рисунком 2.2.1 видно, что программа работает правильно. Все выходные данные верны. Функция обхода отрабатывают правильно.
Написанная программа была выделена в git командой в терминале:
```sh
$ git add 01_Width.c
```
Программа загружена в gitlab командой ```git commit -m ""```, ``` git push```.
Pipeline был успешно пройден c третьего раза.

### 2.3 Программа №2
Основные функциии реализующие бинарное дерево были взяты из предыдущей практической работы. В данной программе необходимо реализовать прямой обход дерева. На рисунке 2.3.1 показан прямой обход дерева.

![Screenshot_8.png](https://www.dropbox.com/s/l0bbycmtkzqo6me/Screenshot_8.png?dl=0&raw=1) 

   *Рисунок 2.3.1 - Прямой обход*

Сначала происходит обход корня, затем левого поддерева и в конце правого поддерева. Таким образом, результат такого обхода будет следующий: 5 3 2 4 7 6 8. При написании кода прямого обхода нельзя было использовать рекурсию. Ниже представлен код функции прямого обхода.
```sh
int printStraight(struct tree * t)
{
    node * a[15];
    int ai = 0;
    node * write[15];
    int wi = 0;
    node * n = t->root;
    while (wi < t->count){
        while (n != NULL){
            wi++;
            if (n->right != NULL){
                ai++;
                a[ai] = n->right;
            }
            write[wi] = n;
            n = n->left;
        }
        n = a[ai];
        ai -= 1;
    }
    int flag = 0;
    for (int i = 1; i <= wi; i++){
        if (flag > 0){
            printf(" ");
        } else {
            flag++;
        }
        printf("%d", write[i]->data);
    }
    return 0;
}
```
Функция Main: 
```sh
int main(){
    int x, i;
    struct tree tr;
    init(&tr);
    for (i = 0; i < 7; i++){
		scanf("%d", &x);
		insert(&tr, x);
	}
	printStraight(&tr);
	printf("\n");
    return 0;
}
```
 Проверим работу написанной программы. Компиляция, работа программы представлена на рисунке 2.3.2.
 
![Screenshot from 2021-05-31 21-33-22.png](https://www.dropbox.com/s/camx4bjf17c722q/Screenshot%20from%202021-05-31%2021-33-22.png?dl=0&raw=1)
 
   *Рисунок 2.3.2 - Работа программы*

Сравнивая работу программы на рисунке 2.3.2 с рисунком 2.3.1 видно, что программа работает правильно. Все выходные данные верны. Функция обхода отрабатывают правильно.
Написанная программа была выделена в git командой в терминале:
```sh
$ git add 02_Straight.c
```
Программа загружена в gitlab командой ```git commit -m ""```, ``` git push```.
Pipeline был успешно пройден cо второго раза.

### 2.4 Программа №3
Основные функциии реализующие бинарное дерево были взяты из предыдущей практической работы. В данной программе необходимо реализовать обратный обход дерева. На рисунке 2.4.1 показан обратный обход дерева.

![Screenshot_9.png](https://www.dropbox.com/s/xyzrez7am7ag197/Screenshot_9.png?dl=0&raw=1)

 *Рисунок 2.4.1 - Обратный обход*

Сначала происходит обход левого поддерева, затем правого поддерева и в конце корня. Таким образом, результат такого обхода будет следующий: 2 4 3 6 8 7 5.  При написании кода обратного обхода нужно было использовать рекурсию. Ниже представлен код функции обратного обхода.
```sh
int printReverse(struct node * n, int flag)
{
    if (n->left != NULL){
        printReverse(n->left, flag + 1);
    }
    if (n->right != NULL){
        printReverse(n->right, flag + 1);
    }
    printf("%d", n->data);
    if (flag > 0){
        printf(" ");
    }
    return 0;
}
```
Функция Main:
```sh
int main(){
    int x, i;
    struct tree tr;
    init(&tr);
    for (i = 0; i < 7; i++){
		scanf("%d", &x);
		insert(&tr, x);
	}
	struct node* n = get_root(&tr);
	printReverse(n, 0);
	printf("\n");
    return 0;
}
```

Проверим работу написанной программы. Компиляция, работа программы представлена на рисунке 2.4.2.
 
![Screenshot from 2021-05-31 21-44-32.png](https://www.dropbox.com/s/i9hka6c4gavycyf/Screenshot%20from%202021-05-31%2021-44-32.png?dl=0&raw=1)
 
   *Рисунок 2.4.2 - Работа программы*

Сравнивая работу программы на рисунке 2.4.2 с рисунком 2.4.1 видно, что программа работает правильно. Все выходные данные верны. Функция обхода отрабатывают правильно.
Написанная программа была выделена в git командой в терминале:
```sh
$ git add 03_Reverse.c
```
Программа загружена в gitlab командой ```git commit -m ""```, ``` git push```.
Pipeline был успешно пройден cо второго раза.

## 3 Заключение
Вывод: в ходе практической работы были написаны программы на языке программирования С, реализующие прямой, обратный обходы и обход в ширину бинарного дерева поиска. Были получены навыки написания программ на языке С.
